# Memory Management 

## Background

Program must be brought (from disk) into memory and placed within a process for it to be run

Main memory and registers are only storage CPU can access directly

Main memory can take many cycles, causing **a stall**

**Cache** sits between main memory and CPU registers

### Differance between cache and register:

**Cahe** helps speed the process because it stores frequently used instruction and data

**Register** hold piece of data, such as storage address and computer instruction

### Memory hierarchy

Register ---> Cahe ---> RAM ---> Disk

from left to right
>- access time decrease
>- amount of storage increase
>- cost per byte decrease

## Protection
Protection of memory required to **ensure correct operation**

CPU must check, every memory access generated in user mode, to be sure it is between **base** and **limit** for that user

**base (relocation) and limit registers** define the **logical** address space

**NOTE:** limit represted as size of process

![image](https://user-images.githubusercontent.com/64374947/106894866-2d211f00-66f8-11eb-92d6-416580a996b4.png)

### Hardware Address Protection with Base and Limit Registers
![image](https://user-images.githubusercontent.com/64374947/106894994-5b9efa00-66f8-11eb-8917-15f327eb10d1.png)


## Multistep Processing of a User Program
![image](https://user-images.githubusercontent.com/64374947/106895321-b89ab000-66f8-11eb-81d0-628efcd1135d.png)

## Binding of Instructions and Data to Memory
Address binding can happen at three different stages:

> 1.**Compile time**: If memory location known a priori, absolute code can be generated
> > **Disadvantage**: Must recompile code if starting location changes

> 2.**Load time**: Must generate relocatable code if memory location is not known at compile time
> > **Disadvantage**: Must reload code if starting location changes


> 3.**Execution time**: Binding delayed until run time if the process can be moved during its execution from one memory segment to another
> > **Disadvantage**: Need hardware support for address maps, such as MMU


## Logical vs. Physical Address Space
**Logical address:** generated by the CPU; also referred to as virtual address

**Physical address:** address seen by memory unit

**NOTE:** Logical and physical addresses **are the same** in
**compile-time and load-time** address-binding
schemes; logical (virtual) and physical addresses
**differ in execution-time** address-binding scheme

**Logical address:** space is the set of all logical
addresses generated by a program
**Physical address:** space is the set of all physical
addresses generated by a program

## Memory-Management Unit (MMU)
Hardware device that at run time maps logical (virtual) to physical address

### Dynamic Relocation Using a Relocation Register
![image](https://user-images.githubusercontent.com/64374947/106896867-d1a46080-66fa-11eb-966d-db483ecc9189.png)

## Dynamic Linking

**Dynamic linking** is particularly useful for libraries

**Static linking:** system libraries combined by theloader into the binary program image

**Dynamic linking:** linking of system libraries postponed until execution time

> - Small piece of code, **stub** used to locate the appropriate memory-resident library routine 
> - Stub replaces itself with the address of the routine, and executes the routine

## Swapping

A process can be swapped temporarily out of
memory to a backing store, and then brought
back into memory for continued execution

**Backing store:** fast disk large enough to
accommodate copies of all memory images for
all users

**Roll out, roll in:** swapping variant used for
priority-based scheduling algorithms.

### Schematic View of Swapping
![image](https://user-images.githubusercontent.com/64374947/106897911-39a77680-66fc-11eb-87d0-f760f427b39e.png)

Does the swapped out process need to swap
back in to same physical addresses?
> - Depends on address binding method

**NOTE:** Major part of swap time is transfer time

## Context Switch Time Including Swapping

If next processes to be put on CPU is not in memory, need to swap out a process andmswap in target process
then Context switch time can then be very high

Can reduce time through decreasing size of memory swapped â€“ by knowing how much memory really being used
> - System calls to inform OS size of used memory via **request_memory() and release_memory()**

### Other constraints as well on swapping
> - assume that process do I/O operation and OS swap it during I/O operation how to deal with coming input ?? here we must use double buffer one for store input to pass it when process pack, but it's adds overhead

